# Упражнения на алгоритмы: Линейный поиск

# Введение

```javascript
let array = ['A', 'B', 'A']
# => [A, B, A]
array.indexOf('A')
# => 0
array.indexOf('B')
# => 1
array.indexOf('C')
# => -1
```
*Рисунок 1*. Поиск индекса элемента в массиве.

Мы собираемся написать метод, который имитирует поведение метода JavaScript. Этот метод возвращает индекс конкретного элемента в массиве или `-1`, если элемент не найден в массиве. Если элемент найден в массиве более одного раза, то возвращается первый индекс. (см. Рисунок 1)

JS извлекает многие функции нижнего уровня программирования, предоставляя нам методы, такие как `.index`. Нам не нужно знать, как находится индекс элемента, нам нужно знать только то, что этот индекс означает и как его использовать в наших программах.

Можно отметить, что это очень хорошо, что JS предоставляет эти абстракции. Тем не менее, мы хотим знать, как реализовать некоторые общие принципы работы. В этой задаче мы сами будем реализовывать работу поиска, используя его конкретный алгоритм - линейный поиск.

### Линейный поиск

В предыдущих задачах мы увидели, что существуют разные способы реализации одного и того же принципа работы, и что существует множество способов поиска данных в коллекции элементов. Понимание различных алгоритмов и шаблонов для поиска и сортировки наборов данных является неотъемлемой частью компьютерных наук.

Одним из основных алгоритмов поиска является линейный поиск. Это алгоритм «грубой силы», где мы просто проверяем каждый элемент по одному разу, пока не найдем элемент, который мы ищем; или просмотрим все элементы и не найдем никакого соответствия.


## Релизы
### Релиз 0: Линейный поиск

```javascript
let numbers = [0, 8, 5, 9, 7, 2]
# => [0, 8, 5, 9, 7, 2]
linearSearch(7, numbers)
# => 4
linearSearch(1, numbers)
# => -1
```
*Рисунок 2*. Пример использования метода линейного поиска.

Напишите метод `linearSearch`, который принимает два аргумента: объект и массив. Метод должен последовательно перебирать каждый элемент и возвращать индекс, в котором объект был изначально найден. Если объект не найден, то метод показывает значение `-1`.

Один тест был написан для нас. Однако нам нужно больше  тренироваться в написании теста, чтобы определить, функционирует ли метод согласно нашим ожиданиям. Есть ли какие-либо крайние случаи, которые нам следует рассмотреть? Столкнулись ли мы с ошибками, для которых у нас должны были быть проведены тесты?

** Ограничения **
Нам нужно написать наш метод, не полагаясь на встроенные методы `Enumerable (map/reduce/fiter)`. Единственными методами, которыми мы можем пользоваться для поиска массива, являются `Array[]` и `Array.length`. Мы свободно можем использовать ключевые слова, такие как `for`,` while`.

### Релиз 1: Глобальный линейный поиск
```javascript
let letters = "bananas".split("")
# => ["b", "a", "n", "a", "n", "a", "s"]
globalLinearSearch("s", letters)
# => [6]
globalLinearSearch("a", letters)
# => [1, 3, 5]
globalLinearSearch("z", letters)
# => []
```
* Рисунок 3 *. Пример использования метода глобального линейного поиска.

В нашем методе `linearSearch` мы вернули индекс первого вхождения элемента. Давайте напишем новый метод `globalLinearSearch`, который возвращает массив всех индексов, в которых найден элемент.

На Рисунке 3 приведен пример использования этого метода. Давайте создадим тесты для проверки работы и затем напишем наш метод, чтобы протестировать его. Что произойдет, если элемент найден только один раз? И что делать, если он не найден?

## Выводы

Линейный поиск - это один из способов поиска коллекции объектов. Давайте рассмотрим производительность нашего алгоритма. Как бы он функционировал, если бы было необходимо просмотреть очень большую коллекцию? Допустим, у нас есть коллекция, содержащая миллион элементов - как бы выполнялся линейный поиск в данном случае?

[implement-enumerable-challenge]: ../../../implement-enumerable-challenge
[rubydocs Array#index]: http://ruby-doc.org/core-2.1.0/Array.html#method-i-index
[wikipedia linear search]: http://en.wikipedia.org/wiki/Linear_search
